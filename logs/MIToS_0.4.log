>>> 'Pkg.add("MIToS")' log
INFO: Cloning cache of ArgParse from git://github.com/carlobaldassi/ArgParse.jl.git
INFO: Cloning cache of Clustering from git://github.com/JuliaStats/Clustering.jl.git
INFO: Cloning cache of FastaIO from git://github.com/carlobaldassi/FastaIO.jl.git
INFO: Cloning cache of IndexedArrays from git://github.com/garrison/IndexedArrays.jl.git
INFO: Cloning cache of MIToS from git://github.com/diegozea/MIToS.jl.git
INFO: Cloning cache of NearestNeighbors from git://github.com/KristofferC/NearestNeighbors.jl.git
INFO: Cloning cache of PairwiseListMatrices from git://github.com/diegozea/PairwiseListMatrices.jl.git
INFO: Cloning cache of ROCAnalysis from git://github.com/davidavdav/ROCAnalysis.jl.git
INFO: Cloning cache of RecipesBase from git://github.com/JuliaPlots/RecipesBase.jl.git
INFO: Cloning cache of Requires from git://github.com/MikeInnes/Requires.jl.git
INFO: Cloning cache of TextWrap from git://github.com/carlobaldassi/TextWrap.jl.git
INFO: Installing ArgParse v0.4.0
INFO: Installing AutoHashEquals v0.0.10
INFO: Installing Clustering v0.7.0
INFO: Installing DataArrays v0.3.12
INFO: Installing DataFrames v0.8.5
INFO: Installing DataStructures v0.5.3
INFO: Installing Distances v0.3.2
INFO: Installing FastaIO v0.2.0
INFO: Installing FileIO v0.2.2
INFO: Installing FixedSizeArrays v0.2.5
INFO: Installing Formatting v0.2.1
INFO: Installing GZip v0.2.20
INFO: Installing Hiccup v0.0.3
INFO: Installing IndexedArrays v0.2.0
INFO: Installing Juno v0.2.7
INFO: Installing Lazy v0.11.6
INFO: Installing LightXML v0.5.0
INFO: Installing MIToS v1.2.3
INFO: Installing MacroTools v0.3.6
INFO: Installing Media v0.2.7
INFO: Installing NearestNeighbors v0.0.5
INFO: Installing PairwiseListMatrices v0.3.0
INFO: Installing ROCAnalysis v0.1.0
INFO: Installing RecipesBase v0.0.6
INFO: Installing Reexport v0.0.3
INFO: Installing Requires v0.2.3
INFO: Installing SortingAlgorithms v0.1.1
INFO: Installing StatsBase v0.12.0
INFO: Installing TextWrap v0.1.6
INFO: Building LightXML
INFO: Package database updated

>>> 'Pkg.test("MIToS")' log
Julia Version 0.4.7
Commit ae26b25 (2016-09-18 16:17 UTC)
Platform Info:
  System: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz
  WORD_SIZE: 64
           Ubuntu 14.04.5 LTS
  uname: Linux 3.13.0-116-generic #163-Ubuntu SMP Fri Mar 31 14:13:22 UTC 2017 x86_64 x86_64
Memory: 2.9392738342285156 GB (586.02734375 MB free)
Uptime: 9896.0 sec
Load Avg:  0.9912109375  1.0283203125  1.0458984375
Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz: 
       speed         user         nice          sys         idle          irq
#1  3499 MHz     442008 s         57 s      45043 s     412441 s         16 s
#2  3499 MHz     328596 s       6192 s      40176 s     582615 s          0 s

  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Nehalem)
  LAPACK: libopenblas64_
  LIBM: libopenlibm
  LLVM: libLLVM-3.3
Environment:
  TERM = vt100
  LD_LIBRARY_PATH = :/usr/local/lib/
  PATH = /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/vagrant/julia/bin/
  JAVA_HOME = /usr/lib/jvm/java-7-oracle
  HOME = /home/vagrant

Package Directory: /home/vagrant/.julia/v0.4
2 required packages:
 - JSON                          0.9.0
 - MIToS                         1.2.3
29 additional packages:
 - ArgParse                      0.4.0
 - AutoHashEquals                0.0.10
 - Clustering                    0.7.0
 - Compat                        0.23.0
 - DataArrays                    0.3.12
 - DataFrames                    0.8.5
 - DataStructures                0.5.3
 - Distances                     0.3.2
 - FastaIO                       0.2.0
 - FileIO                        0.2.2
 - FixedSizeArrays               0.2.5
 - Formatting                    0.2.1
 - GZip                          0.2.20
 - Hiccup                        0.0.3
 - IndexedArrays                 0.2.0
 - Juno                          0.2.7
 - Lazy                          0.11.6
 - LightXML                      0.5.0
 - MacroTools                    0.3.6
 - Media                         0.2.7
 - NearestNeighbors              0.0.5
 - PairwiseListMatrices          0.3.0
 - ROCAnalysis                   0.1.0
 - RecipesBase                   0.0.6
 - Reexport                      0.0.3
 - Requires                      0.2.3
 - SortingAlgorithms             0.1.1
 - StatsBase                     0.12.0
 - TextWrap                      0.1.6
INFO: Testing MIToS

Test General Utils
==================
deleteitems!
get_n_words
hascoordinates
select_element

matrix2list
-----------

list2matrix
-----------

Test findobjects
================
findobjects, isobject and AbstractTest
collectobjects & isobject
collectcaptures & capture
collectcaptures & guess_type

Test eachline for ASCIIString
=============================

Test Residue
============
Convert
GAP
Convert to and from ASCIIString
Ambiguous or not standard residues (are gaps on MIToS)
Comparisons
Random

Three letters <=> One letter (Residue)
--------------------------------------

Tests for IndexedArray
=======================

Creation
--------

Mapping
-------
Test selectvalue
Test selectindex

Comparisons and getindex
------------------------

Iterations
----------

swap! and copy
--------------

push!
-----

Tests for Annotations
=====================

Annotations() for empty annotations
ncolums

Getters & Setters
-----------------

copy, empty, isempty & empty!
-----------------------------

Filters
-------

Tests for Raw Multiple Sequence Alignment a.k.a Matrix{Residue}
================================================================

Parse Raw
---------

Print Raw
---------

Test %
------

Reference and Gapstrip
----------------------

Tests for Multiple Sequence Alignments
======================================

Parse Pfam
----------
Test pfam stockholm parser using the 4 sequence full MSA for PF09645
> Order: Tree
> Inserts lower case
> Gaps as "." or "-" (mixed)
> Pfam version 28.0, based on UniProt release 2014_07
Test parse for string inputs

Keep insert columns
-------------------

Parse Fasta
-----------
Test download of read(URL, ...)
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0100    77  100    77    0     0    226      0 --:--:-- --:--:-- --:--:--   225
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0100   378  100   378    0     0   4215      0 --:--:-- --:--:-- --:--:--  4247
Test parse for string inputs
Test the FASTA parser usando Gao et.al. 2011 example
Sequence identifiers FASTA
Are the parsers (pfam/fasta) getting the same result?
Test parse with ambiguous or not standard residues (are gaps on MIToS)
Dots are part of the alphabet for input.

Selection without Mappings
--------------------------
Test getindex
Test setindex! with copy and deepcopy
Test getresidues, getsequence and getresiduesequence
Test sequence 1 for getresidues and getsequence
Test sequence 2 for getresidues and getsequence
Test sequence 3 for getresidues and getsequence
Test sequence 4 for getresidues and getsequence
Test sequence 5 for getresidues and getsequence
Test sequence 6 for getresidues and getsequence
Test sequence 1 from getresiduesequences
Test sequence 2 from getresiduesequences
Test sequence 3 from getresiduesequences
Test sequence 4 from getresiduesequences
Test sequence 5 from getresiduesequences
Test sequence 6 from getresiduesequences

Size, sequences and columns
---------------------------

AnnotatedAlignedSequence and AlignedSequence
--------------------------------------------
Test getsequence using Index and ID and convert to AlignedSequence

Test Filters!
-------------
filtersequences! with and without annotations
filtercolumns! with and without annotations
Test for BoundsError's on filters with bad masks
Test copy and deepcopy for sequences
Test filtercolumns! for sequences
Test Sequence .== Residue for mask generation
Test filtercolumns!

Test Annotation Getters
-----------------------

Test Gaps and Coverage
----------------------
Test residuefraction
Test coverage

Reference
---------
Test setreference!
Test gapstrip!
Test adjustreference!

Printers
--------
Test asciisequence
Test printfasta
Test printpfam
Tests for Mappings on Annotated Multiple Sequence Alignments
------------------------------------------------------------

Tests for annotation of modifications
-------------------------------------
Test printing annotations and modifications
Test delete MIToS annotations

Test shuffle_...
================

Clustering
==========


percentidentity
---------------

-> Float64
-> Bool

Hobohm I
--------

percentidentity on a MSA
------------------------
SequenceIdentityMatrix

Test meanpercentidentity
------------------------

Test percentsimilarity
======================
Test with gaps
Using SMS's "Ident and Sim" residue groups
Using Bio3D's (2.2) seqidentity residue groups

Tests for PDB
=============

Parse PDB and PDBML
-------------------
2VQC => Missings
Test download
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100 37900  100 37900    0     0  47720      0 --:--:-- --:--:-- --:--:-- 47720
1H4A => Chain A (auth) == Chain X (label)
1SSX => Residues with insert codes: 15A 15B
test @residues
Occupancy != 1.0 and @atom
Best occupancy
@atom with residue wildcard
`read` only atoms with the best occupancy (occupancyfilter=true)
1CBN => Identical PDBe ResNum for Residue 22:

        <residue dbSource="PDBe" dbCoordSys="PDBe" dbResNum="22" dbResName="SER">
          <crossRefDb dbSource="PDB" dbCoordSys="PDBresnum" dbAccessionId="1cbn" dbResNum="22" dbResName="SER" dbChainId="A"/>
          <crossRefDb dbSource="UniProt" dbCoordSys="UniProt" dbAccessionId="P01542" dbResNum="22" dbResName="P"/>
          ....
        <residue dbSource="PDBe" dbCoordSys="PDBe" dbResNum="22" dbResName="PRO">
          <crossRefDb dbSource="PDB" dbCoordSys="PDBresnum" dbAccessionId="1cbn" dbResNum="22" dbResName="PRO" dbChainId="A"/>
          <crossRefDb dbSource="UniProt" dbCoordSys="UniProt" dbAccessionId="P01542" dbResNum="22" dbResName="P"/>
          ...

1AS5 => NMR
1DPO => Inserted residues lack insertion letters
Single unnamed chain in 1DPO contains insertions at postions 184 (Gly, Phe), 188 (Gly, Lys), and 221 (Ala, Leu) but no insertion letters.
1IGY => Insertions have more than one copy of the same amino acid in a single insertion block.
For example, chain B in 1IGY contains a block of four residues inserted at sequence position 82. The block contains Leu-Ser-Ser-Leu.
1HAG => Chain E begins with 1H, 1G, 1F, ... 1A, then 1 (in reverse alphabetic order)
1NSA => Contains a single (unnamed) protein chain with sequence 7A-95A that continues 4-308.
1IAO => Contains in chain B (in this order) 1S, 2S, 323P-334P, 6-94, 94A, 95-188, 1T, 2T

RESTful PDB Interface
=====================
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0100  1097  100  1097    0     0  12344      0 --:--:-- --:--:-- --:--:-- 12465
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0100   531  100   531    0     0   5497      0 --:--:-- --:--:-- --:--:--  5531

Write PDB files
===============

read/write consistency
----------------------
2VQC
1IAO
1NSA
1HAG
1IGY
1DPO
1AS5
1CBN
1SSX

Tests for Contacts on PDB
=========================
1IGY => Test it using data from http://www-cryst.bioc.cam.ac.uk/~richard/piccolo/piccolo.php?PDB=1IGY (28/Sep/2015)
WARNING: RESIDUE: NAG is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: FUL is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: NDG is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: BMA is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: MAN is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: NAG is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: GAL is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: MAN is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: NAG is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: NAG is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: FUC is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: NDG is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: BMA is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: MAN is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: NAG is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: GAL is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: MAN is unknown for MIToS.PDB (AtomsData.jl)
WARNING: RESIDUE: NAG is unknown for MIToS.PDB (AtomsData.jl)

Test findheavy

All the interface between chain A and D
aromatic between chain A and B

Vectorized contact/distance
---------------------------

Proximity Mean
--------------

Test Kabsch algorithm
=====================

RMSF
----

Superimpose PDBs and RMSD
-------------------------
rmsd with Vector{PDBResidue}
Centered
RMSD
coordinatesmatrix, centeredresidues and centeredcoordinates
Superimpose with centered PDBs
RMSF

Tests for SIFTS Mappings
========================

Parse SIFTS
-----------
all against all

siftsmapping
------------
missings
1SSX => Residues with insert codes: 15A 15B
1CBN => Multiple InterProt annotations, the last is used.
Identical PDBe ResNum for Residue 22:

        <residue dbSource="PDBe" dbCoordSys="PDBe" dbResNum="22" dbResName="SER">
          <crossRefDb dbSource="PDB" dbCoordSys="PDBresnum" dbAccessionId="1cbn" dbResNum="22" dbResName="SER" dbChainId="A"/>
          <crossRefDb dbSource="UniProt" dbCoordSys="UniProt" dbAccessionId="P01542" dbResNum="22" dbResName="P"/>
          ....
        <residue dbSource="PDBe" dbCoordSys="PDBe" dbResNum="22" dbResName="PRO">
          <crossRefDb dbSource="PDB" dbCoordSys="PDBresnum" dbAccessionId="1cbn" dbResNum="22" dbResName="PRO" dbChainId="A"/>
          <crossRefDb dbSource="UniProt" dbCoordSys="UniProt" dbAccessionId="P01542" dbResNum="22" dbResName="P"/>
          ...

WARNING: 22 is already in the mapping with the value 22. The value is replaced by 22
WARNING: 25 is already in the mapping with the value 25. The value is replaced by 25
1AS5 => NMR
1DPO => Inserted residues lack insertion letters
Single unnamed chain in 1DPO contains insertions at postions 184 (Gly, Phe), 188 (Gly, Lys), and 221 (Ala, Leu) but no insertion letters.
1IGY => Insertions have more than one copy of the same amino acid in a single insertion block.
For example, chain B in 1IGY contains a block of four residues inserted at sequence position 82. The block contains Leu-Ser-Ser-Leu.
1HAG => Chain E begins with 1H, 1G, 1F, ... 1A, then 1 (in reverse alphabetic order)

Functions for SIFTSResidues
===========================
1NSA => Contains a single (unnamed) protein chain with sequence 7A-95A that continues 4-308.
Test findobjects & read
Test collectcaptures
1IAO => Contains in chain B (in this order) 1S, 323P-334P, 6-94, 94A, 95-188, 1T, 2T
Test collectobjects and isobject

Test download
=============
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0100  5437  100  5437    0     0   2429      0  0:00:02  0:00:02 --:--:--  2430

Tests for ResidueContingencyTables
==================================

Tests for ResidueCount
----------------------

Iterate for N & UseGap:
# Iteration = N: 1 UseGap: true
Test nresidues for ResidueCount{Float64, 1, true}
Test zeros for ResidueCount{Float64, 1, true}
Test iteration interface for ResidueCount{Float64, 1, true}
Test size for ResidueCount{Float64, 1, true}
Test indexing with i for ResidueCount{Float64, 1, true}
Test setindex! with i for ResidueCount{Float64, 1, true}
Test update! for ResidueCount{Float64, 1, true}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 1, true}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 1, true}
# Iteration = N: 1 UseGap: false
Test nresidues for ResidueCount{Float64, 1, false}
Test zeros for ResidueCount{Float64, 1, false}
Test iteration interface for ResidueCount{Float64, 1, false}
Test size for ResidueCount{Float64, 1, false}
Test indexing with i for ResidueCount{Float64, 1, false}
Test setindex! with i for ResidueCount{Float64, 1, false}
Test update! for ResidueCount{Float64, 1, false}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 1, false}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 1, false}
# Iteration = N: 2 UseGap: true
Test nresidues for ResidueCount{Float64, 2, true}
Test zeros for ResidueCount{Float64, 2, true}
Test iteration interface for ResidueCount{Float64, 2, true}
Test size for ResidueCount{Float64, 2, true}
Test indexing with i for ResidueCount{Float64, 2, true}
Test setindex! with i for ResidueCount{Float64, 2, true}
Test update! for ResidueCount{Float64, 2, true}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 2, true}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 2, true}
# Iteration = N: 2 UseGap: false
Test nresidues for ResidueCount{Float64, 2, false}
Test zeros for ResidueCount{Float64, 2, false}
Test iteration interface for ResidueCount{Float64, 2, false}
Test size for ResidueCount{Float64, 2, false}
Test indexing with i for ResidueCount{Float64, 2, false}
Test setindex! with i for ResidueCount{Float64, 2, false}
Test update! for ResidueCount{Float64, 2, false}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 2, false}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 2, false}
# Iteration = N: 3 UseGap: true
Test nresidues for ResidueCount{Float64, 3, true}
Test zeros for ResidueCount{Float64, 3, true}
Test iteration interface for ResidueCount{Float64, 3, true}
Test size for ResidueCount{Float64, 3, true}
Test indexing with i for ResidueCount{Float64, 3, true}
Test setindex! with i for ResidueCount{Float64, 3, true}
Test update! for ResidueCount{Float64, 3, true}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 3, true}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 3, true}
# Iteration = N: 3 UseGap: false
Test nresidues for ResidueCount{Float64, 3, false}
Test zeros for ResidueCount{Float64, 3, false}
Test iteration interface for ResidueCount{Float64, 3, false}
Test size for ResidueCount{Float64, 3, false}
Test indexing with i for ResidueCount{Float64, 3, false}
Test setindex! with i for ResidueCount{Float64, 3, false}
Test update! for ResidueCount{Float64, 3, false}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 3, false}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 3, false}
# Iteration = N: 4 UseGap: true
Test nresidues for ResidueCount{Float64, 4, true}
Test zeros for ResidueCount{Float64, 4, true}
Test iteration interface for ResidueCount{Float64, 4, true}
Test size for ResidueCount{Float64, 4, true}
Test indexing with i for ResidueCount{Float64, 4, true}
Test setindex! with i for ResidueCount{Float64, 4, true}
Test update! for ResidueCount{Float64, 4, true}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 4, true}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 4, true}
# Iteration = N: 4 UseGap: false
Test nresidues for ResidueCount{Float64, 4, false}
Test zeros for ResidueCount{Float64, 4, false}
Test iteration interface for ResidueCount{Float64, 4, false}
Test size for ResidueCount{Float64, 4, false}
Test indexing with i for ResidueCount{Float64, 4, false}
Test setindex! with i for ResidueCount{Float64, 4, false}
Test update! for ResidueCount{Float64, 4, false}
Test apply_pseudocount! with Laplace Smoothing for ResidueCount{Float64, 4, false}
Test fill! with AdditiveSmoothing(0.05) for ResidueCount{Float64, 4, false}
Iteration end


Iterate for UseGap in [true, false]:
# Iteration = UseGap: true
Test indexing with ij for ResidueCount{Float64, 2, true}
Test setindex! with ij for ResidueCount{Float64, 2, true}
Test count! for ResidueCount{Float64, 2, true} and ResidueCount{Float64, 1, true}
Test count! for ResidueCount{Float64, 5, true} and  ResidueCount{Float64, 5, true}}
Test count! for ResidueCount{Float64, 4, true} and  ResidueCount{Float64, 4, true}}
# Iteration = UseGap: false
Test indexing with ij for ResidueCount{Float64, 2, false}
Test setindex! with ij for ResidueCount{Float64, 2, false}
Test count! for ResidueCount{Float64, 2, false} and ResidueCount{Float64, 1, false}
Test count! for ResidueCount{Float64, 5, false} and  ResidueCount{Float64, 5, false}}
Test count! for ResidueCount{Float64, 4, false} and  ResidueCount{Float64, 4, false}}
Iteration end

Test similar
Test count! with SequenceClusters
Test count

Tests for ResidueProbability
----------------------

Iterate for N & UseGap:
# Iteration = N: 1 UseGap: true
Test zeros for ResidueProbability{BigFloat, 1, true}
Test iteration interface for ResidueProbability{BigFloat, 1, true}
Test size for ResidueProbability{BigFloat, 1, true}
Test indexing with i for ResidueProbability{BigFloat, 1, true}
Test setindex! with i for ResidueProbability{BigFloat, 1, true}
Test update! for ResidueProbability{BigFloat, 1, true}
Test normalize! for ResidueProbability{BigFloat, 1, true}
Test fill! with ResidueCount{Int, 1, true} for ResidueProbability{BigFloat, 1, true}
# Iteration = N: 1 UseGap: false
Test zeros for ResidueProbability{BigFloat, 1, false}
Test iteration interface for ResidueProbability{BigFloat, 1, false}
Test size for ResidueProbability{BigFloat, 1, false}
Test indexing with i for ResidueProbability{BigFloat, 1, false}
Test setindex! with i for ResidueProbability{BigFloat, 1, false}
Test update! for ResidueProbability{BigFloat, 1, false}
Test normalize! for ResidueProbability{BigFloat, 1, false}
Test fill! with ResidueCount{Int, 1, false} for ResidueProbability{BigFloat, 1, false}
# Iteration = N: 2 UseGap: true
Test zeros for ResidueProbability{BigFloat, 2, true}
Test iteration interface for ResidueProbability{BigFloat, 2, true}
Test size for ResidueProbability{BigFloat, 2, true}
Test indexing with i for ResidueProbability{BigFloat, 2, true}
Test setindex! with i for ResidueProbability{BigFloat, 2, true}
Test update! for ResidueProbability{BigFloat, 2, true}
Test normalize! for ResidueProbability{BigFloat, 2, true}
Test fill! with ResidueCount{Int, 2, true} for ResidueProbability{BigFloat, 2, true}
# Iteration = N: 2 UseGap: false
Test zeros for ResidueProbability{BigFloat, 2, false}
Test iteration interface for ResidueProbability{BigFloat, 2, false}
Test size for ResidueProbability{BigFloat, 2, false}
Test indexing with i for ResidueProbability{BigFloat, 2, false}
Test setindex! with i for ResidueProbability{BigFloat, 2, false}
Test update! for ResidueProbability{BigFloat, 2, false}
Test normalize! for ResidueProbability{BigFloat, 2, false}
Test fill! with ResidueCount{Int, 2, false} for ResidueProbability{BigFloat, 2, false}
# Iteration = N: 3 UseGap: true
Test zeros for ResidueProbability{BigFloat, 3, true}
Test iteration interface for ResidueProbability{BigFloat, 3, true}
Test size for ResidueProbability{BigFloat, 3, true}
Test indexing with i for ResidueProbability{BigFloat, 3, true}
Test setindex! with i for ResidueProbability{BigFloat, 3, true}
Test update! for ResidueProbability{BigFloat, 3, true}
Test normalize! for ResidueProbability{BigFloat, 3, true}
Test fill! with ResidueCount{Int, 3, true} for ResidueProbability{BigFloat, 3, true}
# Iteration = N: 3 UseGap: false
Test zeros for ResidueProbability{BigFloat, 3, false}
Test iteration interface for ResidueProbability{BigFloat, 3, false}
Test size for ResidueProbability{BigFloat, 3, false}
Test indexing with i for ResidueProbability{BigFloat, 3, false}
Test setindex! with i for ResidueProbability{BigFloat, 3, false}
Test update! for ResidueProbability{BigFloat, 3, false}
Test normalize! for ResidueProbability{BigFloat, 3, false}
Test fill! with ResidueCount{Int, 3, false} for ResidueProbability{BigFloat, 3, false}
# Iteration = N: 4 UseGap: true
Test zeros for ResidueProbability{BigFloat, 4, true}
Test iteration interface for ResidueProbability{BigFloat, 4, true}
Test size for ResidueProbability{BigFloat, 4, true}
Test indexing with i for ResidueProbability{BigFloat, 4, true}
Test setindex! with i for ResidueProbability{BigFloat, 4, true}
Test update! for ResidueProbability{BigFloat, 4, true}
Test normalize! for ResidueProbability{BigFloat, 4, true}
Test fill! with ResidueCount{Int, 4, true} for ResidueProbability{BigFloat, 4, true}
# Iteration = N: 4 UseGap: false
Test zeros for ResidueProbability{BigFloat, 4, false}
Test iteration interface for ResidueProbability{BigFloat, 4, false}
Test size for ResidueProbability{BigFloat, 4, false}
Test indexing with i for ResidueProbability{BigFloat, 4, false}
Test setindex! with i for ResidueProbability{BigFloat, 4, false}
Test update! for ResidueProbability{BigFloat, 4, false}
Test normalize! for ResidueProbability{BigFloat, 4, false}
Test fill! with ResidueCount{Int, 4, false} for ResidueProbability{BigFloat, 4, false}
Iteration end

Test Float64

Iterate for UseGap in [true, false]:
# Iteration = UseGap: true
Test indexing with ij for ResidueProbability{BigFloat, 2, true}
Test setindex! with ij for ResidueProbability{BigFloat, 2, true}
# Iteration = UseGap: false
Test indexing with ij for ResidueProbability{BigFloat, 2, false}
Test setindex! with ij for ResidueProbability{BigFloat, 2, false}
Iteration end

Test pseudofrequencies
Test probabilities
Test delete_dimensions

Tests for Information Measures
==============================

Entropy
-------
Entropy: H(X)
Joint Entropy: H(X,Y)
Joint Entropy: H(X,Y,Z)
Entropy using ResidueCount

Kullback-Leibler
----------------

Mutual Information
------------------
MI(X,Y) = H(X) + H(Y) - H(X,Y)
MI using ResidueCount
MI(X,Y,Z)
MI(X,Y,Z) = H(X) + H(Y) + H(Z) - H(X,Y) - H(X,Z) - H(Y,Z) + H(X,Y,Z)
MI(X,Y,Z) <= min{ H(X,Y), H(X,Z), H(Y,Z) }

Pairwise Gap Percentage
-----------------------

Estimation of measures on a MSA
===============================
This is the example of MI(X, Y)/H(X, Y) from:
Gao, H., Dou, Y., Yang, J., & Wang, J. (2011). New methods to measure residues coevolution in proteins. BMC bioinformatics, 12(1), 206.

Test APC!
=========

Simple examples
===============
MI

MI: Using pseudocount (0.05)
----------------------------

Test APC!

Z-score
MI

MI: Using pseudocount (0.05)
----------------------------

Test APC!

Z-score

Results from Buslje et. al 2009
===============================

MI

Pearson for Z-score: 0.9628041341156327

cMI

MI + clustering

Pearson for Z-score: 0.9367239719588982

MIp

Pearson for MIp: 0.9999999999999999
Pearson for Z-score: 0.9760777857913233

MIp + clustering

Pearson for MIp: 0.9999999999999999
Pearson for Z-score: 0.9594679110412446

Test for BLMI
=============

Test for Pairwise Gap Percentage
================================

Test download from Pfam
=======================
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0100   932  100   932    0     0   1782      0 --:--:-- --:--:-- --:--:--  1785

Test PDB code from Pfam
=======================

Test Mapping PDB/Pfam
=====================

Test Residues
-------------

Test Contacts
=============

Test MSA contact map using PDBResidues from the MSA
---------------------------------------------------

...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

Test hasresidues

Test AUC and Contact Masks
==========================

AUC Example using MI
--------------------

Test scripts
============

STDIN -> STDOUT
---------------
--arg
--list & -a

File -> File
------------
--list & -a

-p (parallel)
-------------
File -> File (--list)
STDIN -> File (--list)

Distances.jl
============

----- =D -----

INFO: MIToS tests passed

>>> End of log
