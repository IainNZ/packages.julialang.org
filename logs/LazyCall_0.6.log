>>> 'Pkg.add("LazyCall")' log
INFO: Cloning cache of LazyCall from https://github.com/bramtayl/LazyCall.jl.git
INFO: Installing DataStructures v0.7.4
INFO: Installing LazyCall v0.2.0
INFO: Installing MacroTools v0.4.0
INFO: Package database updated
INFO: METADATA is out-of-date â€” you may not have the latest version of LazyCall
INFO: Use `Pkg.update()` to get the latest versions of your packages

>>> 'Pkg.test("LazyCall")' log
Julia Version 0.6.2
Commit d386e40c17 (2017-12-13 18:08 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz
  WORD_SIZE: 64
           Ubuntu 14.04.5 LTS
  uname: Linux 3.13.0-135-generic #184-Ubuntu SMP Wed Oct 18 11:55:51 UTC 2017 x86_64 x86_64
Memory: 2.93927001953125 GB (1049.12890625 MB free)
Uptime: 45151.0 sec
Load Avg:  0.9697265625  0.9853515625  0.990234375
Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz: 
       speed         user         nice          sys         idle          irq
#1  3500 MHz    2776681 s       4834 s     132854 s     929709 s         30 s
#2  3500 MHz     669888 s       1614 s      63822 s    3698171 s          0 s

  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Nehalem)
  LAPACK: libopenblas64_
  LIBM: libopenlibm
  LLVM: libLLVM-3.9.1 (ORCJIT, haswell)
Environment:
  TERM = vt100
  LD_LIBRARY_PATH = :/usr/local/lib/
  PATH = /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/vagrant/julia/bin/
  JAVA_HOME = /usr/lib/jvm/java-8-openjdk-amd64
  HOME = /home/vagrant

Package Directory: /home/vagrant/.julia/v0.6
2 required packages:
 - JSON                          0.17.1
 - LazyCall                      0.2.0
19 additional packages:
 - BinDeps                       0.8.6
 - Cairo                         0.5.0
 - ColorTypes                    0.6.7
 - Colors                        0.8.2
 - Compat                        0.55.0
 - DataStructures                0.7.4
 - FixedPointNumbers             0.4.6
 - Graphics                      0.2.0
 - Gtk                           0.13.1
 - MacroTools                    0.4.0
 - NaNMath                       0.3.1
 - NodeJS                        0.3.0
 - Nullables                     0.0.3
 - Reexport                      0.1.0
 - Requires                      0.4.3
 - Rsvg                          0.2.0
 - SHA                           0.5.6
 - URIParser                     0.3.0
 - VegaLite                      0.1.0              ecb31725 (dirty)
INFO: Computing test dependencies for LazyCall...
INFO: Installing DocStringExtensions v0.4.3
INFO: Installing Documenter v0.13.2
INFO: Testing LazyCall
Documenter: setting up build directory.
Documenter: expanding markdown templates.
Documenter: building cross-references.
Documenter: running document checks.
 > checking for missing docstrings.
 !! 137 docstrings potentially missing:

    MacroTools.gatherwheres :: Tuple{Any}
    Base.insert! :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord},Any,Any}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.insert! :: Union{Tuple{DataStructures.SortedDict{K,D,Ord},Any,Any}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.insert! :: Tuple{DataStructures.SortedSet,Any}
    MacroTools.@>> :: Tuple
    DataStructures.dequeue_pair! :: Tuple{DataStructures.PriorityQueue}
    DataStructures.SortedMultiDict :: Tuple{Vararg{Pair,N} where N}
    DataStructures.SortedMultiDict :: Tuple{Base.Order.Ordering,Vararg{Pair,N} where N}
    DataStructures.SortedMultiDict :: Tuple{}
    DataStructures.SortedMultiDict :: Union{Tuple{O}, Tuple{O}} where O<:Base.Order.Ordering
    DataStructures.SortedMultiDict :: Union{Tuple{D}, Tuple{K}, Tuple{Ord,Any}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.SortedMultiDict :: Union{Tuple{Any}, Tuple{D}, Tuple{K}} where D where K
    Base.valtype :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.valtype :: Union{Tuple{DataStructures.SortedDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.heapify :: Union{Tuple{AbstractArray,Base.Order.Ordering}, Tuple{AbstractArray}}
    DataStructures.packdeepcopy :: Union{Tuple{DataStructures.SortedDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.packdeepcopy :: Union{Tuple{DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    Base.merge :: Union{Tuple{DataStructures.SortedDict{K,D,Ord},Vararg{Associative{K,D},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.merge :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord},Vararg{Union{Associative, DataStructures.SortedMultiDict},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.merge :: Tuple{DataStructures.Accumulator,Vararg{DataStructures.Accumulator,N} where N}
    DataStructures.heappush! :: Union{Tuple{AbstractArray,Any,Base.Order.Ordering}, Tuple{AbstractArray,Any}}
    MacroTools.combinedef :: Tuple{Dict}
    DataStructures.SortedDict :: Union{Tuple{Any}, Tuple{D}, Tuple{K}} where D where K
    DataStructures.SortedDict :: Union{Tuple{D}, Tuple{K}, Tuple{Ord,Vararg{Pair,N} where N}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.SortedDict :: Union{Tuple{Ord}, Tuple{Ord}} where Ord<:Base.Order.Ordering
    DataStructures.SortedDict :: Tuple{Vararg{Pair,N} where N}
    DataStructures.SortedDict :: Tuple{Base.Order.Ordering,Vararg{Pair,N} where N}
    DataStructures.SortedDict :: Union{Tuple{Any,Base.Order.Ordering}, Tuple{Any}}
    DataStructures.SortedDict :: Tuple{}
    DataStructures.top_with_handle :: Tuple{DataStructures.MutableBinaryHeap}
    Base.isequal :: Tuple{DataStructures.SortedSet,DataStructures.SortedSet}
    Base.isequal :: Tuple{DataStructures.SortedMultiDict,DataStructures.SortedMultiDict}
    Base.isequal :: Tuple{DataStructures.SortedDict,DataStructures.SortedDict}
    Base.pop! :: Tuple{DataStructures.SortedDict,Any}
    Base.pop! :: Tuple{DataStructures.SortedSet}
    Base.pop! :: Tuple{DataStructures.SortedSet,Any}
    Base.similar :: Union{Tuple{DataStructures.SortedDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.similar :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.similar :: Union{Tuple{DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    DataStructures.OrderedDict
    DataStructures.heapify! :: Union{Tuple{AbstractArray,Base.Order.Ordering}, Tuple{AbstractArray}}
    DataStructures.update! :: Union{Tuple{DataStructures.MutableBinaryHeap{T,Comp} where Comp,Int64,T}, Tuple{T}} where T
    Base.setindex! :: Union{Tuple{DataStructures.SortedDict{K,D,Ord},Any,Any}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    MacroTools.inexpr :: Tuple{Any,Any}
    MacroTools.prewalk :: Tuple{Any,Any}
    Base.haskey :: Tuple{DataStructures.SortedDict,Any}
    Base.haskey :: Tuple{DataStructures.SortedMultiDict,Any}
    Base.haskey :: Tuple{DataStructures.SortedSet,Any}
    MacroTools.rmlines :: Tuple{Any}
    Base.getindex :: Tuple{DataStructures.SortedDict,Any}
    DataStructures.heappop! :: Union{Tuple{AbstractArray,Base.Order.Ordering}, Tuple{AbstractArray}}
    MacroTools.@q :: Tuple{Any}
    Base.eltype :: Union{Tuple{DataStructures.SortedDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.eltype :: Union{Tuple{DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    Base.eltype :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.nlargest :: Union{Tuple{Int64,AbstractArray{T,1}}, Tuple{T}} where T
    Base.symdiff :: Union{Tuple{DataStructures.SortedSet{K,Ord},DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    MacroTools.@esc :: Tuple
    DataStructures.front :: Tuple{DataStructures.Deque}
    MacroTools.@expand :: Tuple{Any}
    Base.first :: Tuple{DataStructures.SortedSet}
    Base.first :: Tuple{DataStructures.SortedMultiDict}
    Base.first :: Tuple{DataStructures.SortedDict}
    DataStructures.CircularBuffer
    DataStructures.counter :: Tuple{Any}
    Base.issubset :: Tuple{Any,DataStructures.SortedSet}
    MacroTools.splitarg :: Tuple{Any}
    DataStructures.top :: Tuple{DataStructures.BinaryHeap}
    DataStructures.CircularDeque
    DataStructures.Queue :: Union{Tuple{Type{T}}, Tuple{T}} where T
    DataStructures.inc! :: Tuple{DataStructures.Accumulator,Any,Number}
    DataStructures.peek :: Tuple{DataStructures.PriorityQueue}
    MacroTools.prettify :: Tuple{Any}
    Base.merge! :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord},Vararg{Union{Associative, DataStructures.SortedMultiDict},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.merge! :: Union{Tuple{DataStructures.SortedDict{K,D,Ord},Vararg{Associative{K,D},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.merge! :: Tuple{DataStructures.Accumulator,DataStructures.Accumulator}
    DataStructures.PriorityQueue
    Base.get! :: Union{Tuple{D}, Tuple{K}, Tuple{Union{Function, Type},DataStructures.SortedDict{K,D,Ord} where Ord<:Base.Order.Ordering,Any}} where D where K
    Base.keytype :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.keytype :: Union{Tuple{DataStructures.SortedDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.keytype :: Union{Tuple{DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    MacroTools.isexpr :: Tuple{Expr}
    DataStructures.isordered :: Union{Tuple{T}, Tuple{Type{T}}} where T<:Associative
    Base.delete! :: Tuple{DataStructures.SortedDict,Any}
    Base.delete! :: Tuple{DataStructures.SortedSet,Any}
    DataStructures.in_same_set :: Tuple{DataStructures.IntDisjointSets,Integer,Integer}
    MacroTools.namify :: Tuple{Symbol}
    DataStructures.nsmallest :: Union{Tuple{Int64,AbstractArray{T,1}}, Tuple{T}} where T
    DataStructures.SortedSet
    DataStructures.SortedSet :: Union{Tuple{K}, Tuple{O}, Tuple{O}} where O<:Base.Order.Ordering where K
    DataStructures.SortedSet :: Tuple{}
    DataStructures.SortedSet :: Union{Tuple{O}, Tuple{O}} where O<:Base.Order.Ordering
    DataStructures.SortedSet :: Union{Tuple{K}, Tuple{}} where K
    DataStructures.dequeue! :: Tuple{DataStructures.PriorityQueue}
    DataStructures.dequeue! :: Tuple{DataStructures.Queue}
    DataStructures.isheap :: Union{Tuple{AbstractArray,Base.Order.Ordering}, Tuple{AbstractArray}}
    Base.union! :: Union{Tuple{DataStructures.SortedSet{K,Ord},Any}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    Base.intersect :: Union{Tuple{DataStructures.SortedSet{K,Ord},Vararg{DataStructures.SortedSet{K,Ord},N} where N}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    Base.setdiff :: Union{Tuple{DataStructures.SortedSet{K,Ord},DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    MacroTools.alias_gensyms :: Tuple{Any}
    DataStructures.ordtype :: Union{Tuple{DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    DataStructures.ordtype :: Union{Tuple{DataStructures.SortedDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.ordtype :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.packcopy :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    DataStructures.packcopy :: Union{Tuple{DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where K
    DataStructures.packcopy :: Union{Tuple{DataStructures.SortedDict{K,D,Ord}}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    MacroTools.postwalk :: Tuple{Any,Any}
    DataStructures.enqueue! :: Tuple{DataStructures.Queue,Any}
    DataStructures.enqueue! :: Tuple{DataStructures.PriorityQueue,Any,Any}
    DataStructures.enqueue! :: Union{Tuple{DataStructures.PriorityQueue{K,V,O} where O<:Base.Order.Ordering,Pair{K,V}}, Tuple{K}, Tuple{V}} where V where K
    MacroTools.@> :: Tuple
    Base.get :: Union{Tuple{D}, Tuple{K}, Tuple{Union{Function, Type},DataStructures.SortedDict{K,D,Ord} where Ord<:Base.Order.Ordering,Any}} where D where K
    DataStructures.back :: Tuple{DataStructures.Deque}
    MacroTools.unblock :: Tuple{Any}
    Base.find :: Tuple{DataStructures.SortedDict,Any}
    Base.push! :: Union{Tuple{DataStructures.SortedMultiDict{K,D,Ord} where Ord<:Base.Order.Ordering,Pair}, Tuple{D}, Tuple{K}} where D where K
    Base.push! :: Union{Tuple{DataStructures.SortedDict{K,D,Ord} where Ord<:Base.Order.Ordering,Pair}, Tuple{D}, Tuple{K}} where D where K
    Base.push! :: Tuple{DataStructures.SortedSet,Any}
    DataStructures.orderobject :: Tuple{DataStructures.SortedSet}
    DataStructures.orderobject :: Tuple{DataStructures.SortedMultiDict}
    DataStructures.orderobject :: Tuple{DataStructures.SortedDict}
    DataStructures.reset! :: Tuple{DataStructures.Accumulator,Any}
    MacroTools.combinearg :: NTuple{4,Any}
    DataStructures.find_root :: Union{Tuple{DataStructures.DisjointSets{T},T}, Tuple{T}} where T
    DataStructures.deque :: Union{Tuple{Type{T}}, Tuple{T}} where T
    DataStructures.dec! :: Tuple{DataStructures.Accumulator,Any,Number}
    Base.getkey :: Union{Tuple{DataStructures.SortedDict{K,D,Ord},Any,Any}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord<:Base.Order.Ordering where D where K
    Base.union :: Tuple{DataStructures.SortedSet,Vararg{Any,N} where N}
    Base.setdiff! :: Tuple{DataStructures.SortedSet,Any}
    MacroTools.splitdef :: Tuple{Any}
    Base.last :: Tuple{DataStructures.SortedSet}
    Base.last :: Tuple{DataStructures.SortedMultiDict}
    Base.last :: Tuple{DataStructures.SortedDict}
    Base.in :: Union{Tuple{D}, Tuple{K}, Tuple{Ord}, Tuple{Pair,DataStructures.SortedDict{K,D,Ord}}} where Ord<:Base.Order.Ordering where D where K
    Base.in :: Tuple{Pair,DataStructures.SortedMultiDict}
    DataStructures.compare :: Tuple{Union{DataStructures.SortedDict, DataStructures.SortedMultiDict, DataStructures.SortedSet},DataStructures.Tokens.IntSemiToken,DataStructures.Tokens.IntSemiToken}
    MacroTools.isdef :: Tuple{Any}

 > running doctests.
 > checking footnote links.
Documenter: populating indices.
ERROR: LoadError: `makedocs` encountered an error. Terminating build
Stacktrace:
 [1] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/vagrant/.julia/v0.6/Documenter/src/Builder.jl:202
 [2] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document, ::Vararg{Documenter.Documents.Document,N} where N) at /home/vagrant/.julia/v0.6/Documenter/src/Selectors.jl:167
 [3] cd(::Documenter.##2#3{Documenter.Documents.Document}, ::String) at ./file.jl:70
 [4] #makedocs#1(::Bool, ::Array{Any,1}, ::Function) at /home/vagrant/.julia/v0.6/Documenter/src/Documenter.jl:202
 [5] (::Documenter.#kw##makedocs)(::Array{Any,1}, ::Documenter.#makedocs) at ./<missing>:0
 [6] include_from_node1(::String) at ./loading.jl:576
 [7] include(::String) at ./sysimg.jl:14
 [8] process_options(::Base.JLOptions) at ./client.jl:305
 [9] _start() at ./client.jl:371
while loading /home/vagrant/.julia/v0.6/LazyCall/test/runtests.jl, in expression starting on line 4
==============================[ ERROR: LazyCall ]===============================

failed process: Process(`/home/vagrant/julia/bin/julia -Cx86-64 -J/home/vagrant/julia/lib/julia/sys.so --compile=yes --depwarn=yes --check-bounds=yes --code-coverage=none --color=no --compilecache=yes /home/vagrant/.julia/v0.6/LazyCall/test/runtests.jl`, ProcessExited(1)) [1]

================================================================================
INFO: Removing DocStringExtensions v0.4.3
INFO: Removing Documenter v0.13.2
ERROR: LazyCall had test errors

>>> End of log
