>>> 'Pkg.add("SIMD")' log
WARNING: Base.Pkg is deprecated, run `using Pkg` instead
 in module Main
[ Info: Cloning cache of SIMD from https://github.com/eschnett/SIMD.jl.git
[ Info: Installing SIMD v0.3.0
[ Info: Package database updated
┌ Info: METADATA is out-of-date — you may not have the latest version of SIMD
└ Use `Pkg.update()` to get the latest versions of your packages

>>> 'Pkg.test("SIMD")' log
WARNING: Base.versioninfo is deprecated: it has been moved to the standard library package `InteractiveUtils`.
Add `using InteractiveUtils` to your imports.
 in module Main
WARNING: Base.versioninfo is deprecated: it has been moved to the standard library package `InteractiveUtils`.
Add `using InteractiveUtils` to your imports.
 in module Main
Julia Version 0.7.0-DEV.5059
Commit f1b23284bb (2018-05-10 22:10 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
      Ubuntu 14.04.5 LTS
  uname: Linux 3.13.0-143-generic #192-Ubuntu SMP Tue Feb 27 10:45:36 UTC 2018 x86_64 x86_64
  CPU: Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz: 
              speed         user         nice          sys         idle          irq
       #1  3499 MHz    3220082 s        189 s     225253 s     877325 s         37 s
       #2  3499 MHz     698719 s       6910 s      72156 s    4222630 s          1 s
       
  Memory: 2.939197540283203 GB (503.18359375 MB free)
  Uptime: 50968.0 sec
  Load Avg:  1.02197265625  0.97314453125  0.9599609375
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-6.0.0 (ORCJIT, haswell)
Environment:
  TERM = vt100
  LD_LIBRARY_PATH = :/usr/local/lib/
  PATH = /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/vagrant/julia/bin/
  JAVA_HOME = /usr/lib/jvm/java-8-openjdk-amd64
  HOME = /home/vagrant
Packages:
  Package Directory: /home/vagrant/.julia/v0.7
  Package Status:
2 required packages:
 - JSON                          0.17.2
 - SIMD                          0.3.0
3 additional packages:
 - Compat                        0.64.0
 - Nullables                     0.0.5
 - tmpUHLa7Z                     0.0.0-             non-repo (unregistered)
WARNING: Base.Pkg is deprecated, run `using Pkg` instead
 in module Main
[ Info: Testing SIMD
[ Info: Basic definitions
[ Info: Type properties
[ Info: Type conversion
[ Info: Element-wise access
[ Info: Integer arithmetic functions
[ Info: Floating point arithmetic functions
[ Info: Type promotion
[ Info: Reduction operations
[ Info: Load and store functions
WARNING: importing deprecated binding Base.uninitialized into SIMD.
WARNING: Base.uninitialized is deprecated, use undef instead.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:272
WARNING: Base.uninitialized is deprecated, use undef instead.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:272
WARNING: Base.uninitialized is deprecated, use undef instead.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:272
WARNING: Base.uninitialized is deprecated, use undef instead.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:285
WARNING: Base.uninitialized is deprecated, use undef instead.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:285
WARNING: Base.uninitialized is deprecated, use undef instead.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:285
[ Info: Real-world examples
WARNING: Base.@code_llvm is deprecated: it has been moved to the standard library package `InteractiveUtils`.
Add `using InteractiveUtils` to your imports.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:371
WARNING: Base.@code_native is deprecated: it has been moved to the standard library package `InteractiveUtils`.
Add `using InteractiveUtils` to your imports.
  likely near /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:371

; Function vsum
; Location: /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:320
define double @julia_vsum_35463(%jl_value_t addrspace(10)* nonnull dereferenceable(40), %jl_value_t addrspace(10)*) {
top:
  %gcframe = alloca %jl_value_t addrspace(10)*, i32 3
  %2 = bitcast %jl_value_t addrspace(10)** %gcframe to i8*
  call void @llvm.memset.p0i8.i32(i8* %2, i8 0, i32 24, i32 0, i1 false)
  %thread_ptr = call i8* asm "movq %fs:0, $0", "=r"()
  %ptls_i8 = getelementptr i8, i8* %thread_ptr, i64 -10920
  %ptls = bitcast i8* %ptls_i8 to %jl_value_t***
; Function length; {
; Location: abstractarray.jl:156
; Function size; {
; Location: subarray.jl:57
; Function axes; {
; Location: subarray.jl:344
; Function getproperty; {
; Location: sysimg.jl:18
  %3 = getelementptr %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)** %gcframe, i32 0
  %4 = bitcast %jl_value_t addrspace(10)** %3 to i64*
  store i64 2, i64* %4
  %5 = getelementptr %jl_value_t**, %jl_value_t*** %ptls, i32 0
  %6 = getelementptr %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)** %gcframe, i32 1
  %7 = bitcast %jl_value_t addrspace(10)** %6 to %jl_value_t***
  %8 = load %jl_value_t**, %jl_value_t*** %5
  store %jl_value_t** %8, %jl_value_t*** %7
  %9 = bitcast %jl_value_t*** %5 to %jl_value_t addrspace(10)***
  store %jl_value_t addrspace(10)** %gcframe, %jl_value_t addrspace(10)*** %9
  %10 = addrspacecast %jl_value_t addrspace(10)* %0 to %jl_value_t addrspace(11)*
  %11 = bitcast %jl_value_t addrspace(11)* %10 to i8 addrspace(11)*
  %12 = getelementptr i8, i8 addrspace(11)* %11, i64 8
;}
; Function _indices_sub; {
; Location: subarray.jl:349
; Function unsafe_indices; {
; Location: abstractarray.jl:94
; Function unsafe_length; {
; Location: range.jl:391
; Function last; {
; Location: range.jl:438
; Function getproperty; {
; Location: sysimg.jl:18
  %13 = getelementptr inbounds i8, i8 addrspace(11)* %11, i64 16
  %14 = bitcast i8 addrspace(11)* %13 to i64 addrspace(11)*
;}}
; Function first; {
; Location: range.jl:433
; Function getproperty; {
; Location: sysimg.jl:18
  %15 = bitcast i8 addrspace(11)* %12 to i64 addrspace(11)*
;}}
; Function -; {
; Location: int.jl:52
  %16 = load i64, i64 addrspace(11)* %14, align 8
  %17 = load i64, i64 addrspace(11)* %15, align 8
  %18 = sub i64 %16, %17
;}
; Function +; {
; Location: int.jl:53
  %19 = add i64 %18, 1
;}}
; Function Type; {
; Location: range.jl:212
; Function Type; {
; Location: range.jl:210
; Function max; {
; Location: promotion.jl:435
  %20 = icmp sgt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
;}}}}}}}}
; Function rem; {
; Location: int.jl:230
  %22 = and i64 %21, 3
;}
; Function ==; {
; Location: promotion.jl:424
  %23 = icmp eq i64 %22, 0
;}
  br i1 %23, label %L46, label %L41

L41:                                              ; preds = %top
; Function Type; {
; Location: boot.jl:289
  %24 = bitcast %jl_value_t*** %ptls to i8*
  %25 = call noalias nonnull %jl_value_t addrspace(10)* @jl_gc_pool_alloc(i8* %24, i32 1424, i32 16)
  %26 = bitcast %jl_value_t addrspace(10)* %25 to %jl_value_t addrspace(10)* addrspace(10)*
  %27 = getelementptr %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)* addrspace(10)* %26, i64 -1
  store %jl_value_t addrspace(10)* addrspacecast (%jl_value_t* inttoptr (i64 139671921573968 to %jl_value_t*) to %jl_value_t addrspace(10)*), %jl_value_t addrspace(10)* addrspace(10)* %27
  %28 = bitcast %jl_value_t addrspace(10)* %25 to %jl_value_t addrspace(10)* addrspace(10)*
  store %jl_value_t addrspace(10)* addrspacecast (%jl_value_t* inttoptr (i64 139671825350464 to %jl_value_t*) to %jl_value_t addrspace(10)*), %jl_value_t addrspace(10)* addrspace(10)* %28, align 8
;}
  %29 = addrspacecast %jl_value_t addrspace(10)* %25 to %jl_value_t addrspace(12)*
  %30 = getelementptr %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)** %gcframe, i32 2
  store %jl_value_t addrspace(10)* %25, %jl_value_t addrspace(10)** %30
  call void @jl_throw(%jl_value_t addrspace(12)* %29)
  unreachable

L46:                                              ; preds = %top
; Location: /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:322
; Function Colon; {
; Location: range.jl:23
; Function _colon; {
; Location: range.jl:25
; Function Type; {
; Location: range.jl:180
; Function Type; {
; Location: range.jl:128
  %31 = call i64 @julia_steprange_last_23067(i64 1, i64 4, i64 %21)
;}}}}
; Function done; {
; Location: range.jl:463
; Function isempty; {
; Location: range.jl:352
; Function &; {
; Location: bool.jl:40
  %32 = icmp slt i64 %31, 1
;}}
; Function +; {
; Location: int.jl:53
  %33 = add i64 %31, 4
;}
; Function ==; {
; Location: promotion.jl:424
  %34 = icmp eq i64 %33, 1
;}}
  %35 = or i1 %32, %34
  br i1 %35, label %L227, label %if1.lr.ph.if1.lr.ph.split_crit_edge

if1.lr.ph.if1.lr.ph.split_crit_edge:              ; preds = %L46
  %36 = bitcast %jl_value_t addrspace(11)* %10 to %jl_value_t addrspace(10)* addrspace(11)*
  %37 = load %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)* addrspace(11)* %36, align 8
  %38 = getelementptr i8, i8 addrspace(11)* %11, i64 24
  %39 = bitcast i8 addrspace(11)* %38 to i64 addrspace(11)*
  %40 = load i64, i64 addrspace(11)* %39, align 8
  %41 = addrspacecast %jl_value_t addrspace(10)* %37 to %jl_value_t addrspace(11)*
  %42 = bitcast %jl_value_t addrspace(11)* %41 to i8* addrspace(11)*
  %43 = load i8*, i8* addrspace(11)* %42, align 8
  br label %if1

L227:                                             ; preds = %if1, %L46
  %sv.sroa.0.0.lcssa = phi <4 x double> [ zeroinitializer, %L46 ], [ %res.i55, %if1 ]
; Location: /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:326
; Function sum; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:1168
; Function llvmwrapreduce; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:1123
; Function @generated body; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:1156
  %vec_2_1.i = shufflevector <4 x double> %sv.sroa.0.0.lcssa, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %vec_2_2.i = shufflevector <4 x double> %sv.sroa.0.0.lcssa, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %vec_2.i = fadd <2 x double> %vec_2_1.i, %vec_2_2.i
  %vec_1_1.i = shufflevector <2 x double> %vec_2.i, <2 x double> undef, <1 x i32> zeroinitializer
  %vec_1_2.i = shufflevector <2 x double> %vec_2.i, <2 x double> undef, <1 x i32> <i32 1>
  %vec_1.i = fadd <1 x double> %vec_1_1.i, %vec_1_2.i
  %res.i = extractelement <1 x double> %vec_1.i, i32 0
;}}}
  %44 = getelementptr %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)** %gcframe, i32 1
  %45 = load %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)** %44
  %46 = getelementptr %jl_value_t**, %jl_value_t*** %ptls, i32 0
  %47 = bitcast %jl_value_t*** %46 to %jl_value_t addrspace(10)**
  store %jl_value_t addrspace(10)* %45, %jl_value_t addrspace(10)** %47
  ret double %res.i

if1:                                              ; preds = %if1.lr.ph.if1.lr.ph.split_crit_edge, %if1
  %"#temp#.058" = phi i64 [ 1, %if1.lr.ph.if1.lr.ph.split_crit_edge ], [ %48, %if1 ]
  %sv.sroa.0.057 = phi <4 x double> [ zeroinitializer, %if1.lr.ph.if1.lr.ph.split_crit_edge ], [ %res.i55, %if1 ]
; Location: /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:322
; Function next; {
; Location: range.jl:461
; Function +; {
; Location: int.jl:53
  %48 = add i64 %"#temp#.058", 4
;}}
; Location: /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:323
; Function vload; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:1268
; Function vload; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:1268
; Function pointer; {
; Location: subarray.jl:327
; Function +; {
; Location: int.jl:53
  %49 = add i64 %40, %"#temp#.058"
;}
; Function pointer; {
; Location: abstractarray.jl:850
; Function *; {
; Location: int.jl:54
  %50 = shl i64 %49, 3
  %51 = add i64 %50, -8
;}
; Function +; {
; Location: pointer.jl:155
  %52 = getelementptr i8, i8* %43, i64 %51
;}}}
; Function vload; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:1231
; Function @generated body; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:1255
  %ptr.i = bitcast i8* %52 to <4 x double>*
  %res.i56 = load <4 x double>, <4 x double>* %ptr.i, align 8
;}}}}
; Location: /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:324
; Function +; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:995
; Function llvmwrap; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:550
; Function llvmwrap; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:550
; Function @generated body; {
; Location: /home/vagrant/.julia/v0.7/SIMD/src/SIMD.jl:569
  %res.i55 = fadd <4 x double> %sv.sroa.0.057, %res.i56
;}}}}
; Location: /home/vagrant/.julia/v0.7/SIMD/test/runtests.jl:322
; Function done; {
; Location: range.jl:463
; Function ==; {
; Location: promotion.jl:424
  %53 = icmp eq i64 %48, %33
;}}
  br i1 %53, label %L227, label %if1
}
	.text
; Function vsum {
; Location: runtests.jl:320
	pushq	%r14
	pushq	%rbx
	subq	$24, %rsp
	movq	%rdi, %rbx
	xorpd	%xmm0, %xmm0
	movapd	%xmm0, (%rsp)
	movq	$0, 16(%rsp)
	movq	%fs:0, %rax
; Function length; {
; Location: abstractarray.jl:156
; Function size; {
; Location: subarray.jl:57
; Function axes; {
; Location: subarray.jl:344
; Function getproperty; {
; Location: sysimg.jl:18
	movq	$2, (%rsp)
	movq	-10920(%rax), %rcx
	movq	%rcx, 8(%rsp)
	movq	%rsp, %rcx
	movq	%rcx, -10920(%rax)
	leaq	-10920(%rax), %r14
;}
; Function _indices_sub; {
; Location: subarray.jl:349
; Function unsafe_indices; {
; Location: abstractarray.jl:94
; Function unsafe_length; {
; Location: range.jl:391
; Function -; {
; Location: int.jl:52
	movq	16(%rbx), %rax
	subq	8(%rbx), %rax
	xorl	%edx, %edx
;}}
; Function unsafe_length; {
; Location: int.jl:53
	addq	$1, %rax
;}}
; Function unsafe_indices; {
; Location: promotion.jl:435
	cmovnsq	%rax, %rdx
;}}}}}
; Function ==; {
; Location: promotion.jl:424
	testb	$3, %dl
;}
	jne	L244
; Location: runtests.jl:322
; Function Colon; {
; Location: range.jl:23
; Function _colon; {
; Location: range.jl:25
; Function Type; {
; Location: range.jl:180
; Function Type; {
; Location: range.jl:128
	movabsq	$steprange_last, %rax
	movl	$1, %edi
	movl	$4, %esi
	callq	*%rax
;}}}}
; Function done; {
; Location: range.jl:463
; Function isempty; {
; Location: range.jl:352
; Function &; {
; Location: bool.jl:40
	testq	%rax, %rax
;}}}
	jle	L205
	leaq	4(%rax), %rcx
	xorpd	%xmm0, %xmm0
; Location: runtests.jl:322
	cmpq	$1, %rcx
	xorpd	%xmm2, %xmm2
	je	L213
	movq	(%rbx), %rdx
	movq	24(%rbx), %rcx
; Location: runtests.jl:322
	addq	$3, %rax
	shlq	$3, %rcx
	addq	(%rdx), %rcx
	xorpd	%xmm2, %xmm2
	xorpd	%xmm0, %xmm0
	nopl	(%rax)
; Location: runtests.jl:323
; Function vload; {
; Location: SIMD.jl:1268
; Function vload; {
; Location: SIMD.jl:1268
; Function vload; {
; Location: SIMD.jl:1231
; Function @generated body; {
; Location: SIMD.jl:1255
L176:
	movupd	(%rcx), %xmm1
;}}}}
; Location: runtests.jl:324
; Function +; {
; Location: SIMD.jl:995
; Function llvmwrap; {
; Location: SIMD.jl:550
; Function llvmwrap; {
; Location: SIMD.jl:550
; Function @generated body; {
; Location: SIMD.jl:569
	addpd	%xmm1, %xmm2
;}}}}
; Location: runtests.jl:323
; Function vload; {
; Location: SIMD.jl:1268
; Function vload; {
; Location: SIMD.jl:1268
; Function vload; {
; Location: SIMD.jl:1231
; Function @generated body; {
; Location: SIMD.jl:1255
	movupd	16(%rcx), %xmm1
;}}}}
; Location: runtests.jl:324
; Function +; {
; Location: SIMD.jl:995
; Function llvmwrap; {
; Location: SIMD.jl:550
; Function llvmwrap; {
; Location: SIMD.jl:550
; Function @generated body; {
; Location: SIMD.jl:569
	addpd	%xmm1, %xmm0
;}}}}
; Location: runtests.jl:322
; Function done; {
; Location: range.jl:463
; Function ==; {
; Location: promotion.jl:424
	addq	$32, %rcx
	addq	$-4, %rax
;}}
	jne	L176
	jmp	L213
L205:
	xorpd	%xmm0, %xmm0
	xorpd	%xmm2, %xmm2
; Location: runtests.jl:326
; Function sum; {
; Location: SIMD.jl:1168
; Function llvmwrapreduce; {
; Location: SIMD.jl:1123
; Function @generated body; {
; Location: SIMD.jl:1156
L213:
	addpd	%xmm0, %xmm2
	movapd	%xmm2, %xmm0
	movhlps	%xmm0, %xmm0            # xmm0 = xmm0[1,1]
	addsd	%xmm2, %xmm0
;}}}
	movq	8(%rsp), %rax
	movq	%rax, (%r14)
	addq	$24, %rsp
	popq	%rbx
	popq	%r14
	retq
; Location: runtests.jl:320
; Function Type; {
; Location: boot.jl:289
L244:
	movabsq	$jl_gc_pool_alloc, %rax
	movl	$1424, %esi             # imm = 0x590
	movl	$16, %edx
	movq	%r14, %rdi
	callq	*%rax
	movabsq	$jl_system_image_data, %rcx
	movq	%rcx, -8(%rax)
	movabsq	$139671825350464, %rcx  # imm = 0x7F07E188FF40
	movq	%rcx, (%rax)
	movq	%rax, 16(%rsp)
;}
	movabsq	$jl_throw, %rcx
	movq	%rax, %rdi
	callq	*%rcx
	nopl	(%rax)
;}
[ Info: Vector shuffles
[ Info: SIMD tests passed

>>> End of log
